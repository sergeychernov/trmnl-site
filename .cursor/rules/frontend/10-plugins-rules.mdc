---
globs: plugins/**
alwaysApply: false
---
## Правила Cursor — плагины отображения

### Цель
- Плагины генерируют монохромное изображение для TRMNL на основе настроек пользователя и устройства.
- Поддержка размеров задаётся через `outputSizes` (набор пресетов и/или отсутствие ограничений).

### Контракт плагина
- Файл: `plugins/${pluginName}/index.ts`, экспорт по умолчанию:
  - `id: string`, `name: string`
  - `outputSizes: Array<{ width?: number; height?: number }>` — список поддерживаемых размеров:
    - если указаны и `width`, и `height` — фиксированный пресет (конкретный размер);
    - если указано только `width` — ширина фиксирована, высота не ограничена;
    - если указана только `height` — высота фиксирована, ширина не ограничена;
    - если объект пустой `{}` — без ограничений по размеру;
    - **пустой массив `[]` — без ограничений по размерам вообще** (любой `width`/`height`).
  - `defaultSettings: TSettings` — значения по умолчанию
  - `validate(value): value is TSettings` — рантайм‑валидация
  - `render(args: RenderArgs<TSettings>): Promise<MonochromeImage> | React.ReactElement`
    - `RenderArgs<TSettings>`:
      - `user?: UserSettings`
      - `settings?: TSettings`
      - `context?: { deviceId: string | null; baseUrl: string }`
      - `index: number` — порядковый номер блока на экране (начиная с 1)
      - `width: number`, `height: number` — целевой размер изображения
- Регистрация плагина: `plugins/index.ts` (реестр и функции `listPlugins`, `getPlugin`)

### Формат изображения
- `MonochromeImage`:
  - `width`, `height` — пиксели
  - `data: Uint8Array` — 1 бит на пиксель, упакован побайтно (MSB→LSB), порядок: строка за строкой

### Серверный рендер и совместимость размеров
- Для серверного рендера используется обёртка `renderPlugin(plugin, args)`:
  - выполняет проверку размеров через `isSizeAllowed(plugin.outputSizes, width, height)`;
  - принимает результат `render`:
    - если это `ReactElement`, преобразует OG‑пайплайном в 1bpp (используются системные шрифты Noto Sans / Noto Sans Mono);
    - если это `MonochromeImage`, возвращает как есть.
- Если размер не поддержан — возвращается `null`, вызывающая сторона должна обработать это (обычно 400).
- Рекомендуется перечислять все поддерживаемые пресеты в `outputSizes`. Если ограничений нет — используйте `[]` или `{}`.

### API предпросмотра плагина
- Эндпойнт: `/api/render/plugin`
- Query‑параметры:
  - `plugin` — идентификатор плагина (обязателен)
  - `width`, `height` — размеры в пикселях (обязательны, > 0)
  - `index` — индекс блока (необязателен, по умолчанию 1)
  - `settings` — JSON‑строка с настройками плагина (необязателен)
- Ответ: монохромный `image/bmp` (1bpp). При неподдерживаемом размере — `400`.

### Настройки
- Общие настройки:
  - Пользователь: `{ name: string; age: number }`
  - Устройство: `{ pluginId: string; pluginSettings: unknown }`
- Рекомендуемые настройки плагина:
  - `orientation: "landscape" | "portrait"` — влияет на ориентацию контента
  - Дополнительные параметры (текст, источники данных и т.д.) — по задаче
 - Плагин не должен зависеть от `baseUrl`/`deviceId` через `device` — эти значения приходят в `context`.

### Ограничения и рекомендации
- Рекомендованный размер TRMNL: 800×480 (см. BYOS Next.js README `https://github.com/usetrmnl/byos_next/blob/main/README.md`).
  - Если плагин поддерживает только этот размер, укажите `outputSizes: [{ width: 800, height: 480 }]`.
  - Если плагин поддерживает несколько пресетов — перечислите их в `outputSizes`.
  - Если плагин не ограничивает размеры — укажите `outputSizes: []` или включите пресет `{}`.
- Производительность: избегать лишних аллокаций; сложность O(width × height).
- Детерминизм: `render` должен быть чистым относительно входных данных.
- Кросс‑платформенность: не использовать Node‑специфику в плагинах, если они вызываются в браузере.
  - Если `render` возвращает `ReactElement`, избегайте побочных эффектов и сетевых запросов — OG‑пайплайн должен быть детерминированным.

### UI редактора настроек (Editor.tsx)
- Приоритетная библиотека UI — MUI (`@mui/material`).
  - Формы: `TextField`, `Select` (+ `FormControl/InputLabel/MenuItem`), `Switch` (+ `FormControlLabel`), `Checkbox/Radio` по необходимости.
  - Навигация внутри редактора: `Tabs/Tab` (см. документацию MUI — Tabs).
  - Layout: `Stack/Box/Grid`, отступы через `sx` и тему.
  - Валидации — через свойства MUI (`error`, `helperText`) и типы TS; текст ошибок краткий.
- SSR уже настроен через `AppRouterCacheProvider` — не удалять провайдеры MUI в `app/providers.tsx`.
- Tailwind допускается точечно (утилитарные классы), но компоненты формы — только MUI.

### Рендер текста (canvasText)
- Используем только `@lib/canvasText` для вывода текста в монохромный буфер:
  - Измерение: `measureCanvasText(text, opts)` вернёт `{ width, height }`.
  - Рендер: `drawCanvasTextToBuffer({ data, width, height }, text, x, yTop, opts)`.
  - Тип буфера: `{ data: Uint8Array; width: number; height: number }` (1 бит/пиксель, MSB→LSB).
- Параметры `opts`:
  - `fontFamily` (рекомендуется `"monospace"` для стабильной верстки),
  - `fontSize` (px), `fontWeight`, `letterSpacing` (px), `thresholdAlpha` (порог альфа для бинаризации),
  - опционально `fontPathToRegister` + `fontFamily` — для подключения кастомного TTF.
- Подбор размера:
  - Сначала измерить текст `measureCanvasText`, при необходимости уменьшать `fontSize`, пока он укладывается в рамки.
  - Центрирование: вычислить `x = (width - measured.width)/2`, `y = (height - measured.height)/2` (с запасом по полям).
- Портретная ориентация:
  - Рендерить во временный буфер тем же API, затем переносить пиксели с поворотом (см. `plugins/calendar/index.ts`).
- Нельзя:
  - использовать старые утилиты bitmap‑шрифтов или собственные битовые маски глифов,
  - напрямую писать текст в буфер, минуя `canvasText`.

### Работа с SVG/иконками
- OG‑пайплайн Vercel/`next/og` ненадёжно рендерит `<svg>` и `<img src="data:image/svg+xml">`. Чтобы не терять иконки, конвертируйте их в растровый формат заранее.
- Для Phosphor‑иконок используйте `scripts/gen-hello-icons.mjs` — он собирает PNG в `plugins/hello/icon-images.ts` (base64‑данные в `HELLO_ICON_IMAGES`).
- В рендерах подключайте эти данные и вставляйте обычный `<img src={...} width={...} height={...} />` (c локальным `eslint-disable-next-line @next/next/no-img-element` при необходимости).
- При добавлении новых иконок расширяйте список в скрипте, запускайте `node scripts/gen-hello-icons.mjs` и коммитьте обновлённый `icon-images.ts`.


