---
alwaysApply: true
---
## Правила Cursor — проектные (глобальные)

### Коммуникация
- Отвечай кратко на русском. Детали — по запросу.
- Используй заголовки `##/###`, списки `-`, инлайн-код в бэктиках. Ссылки — markdown.
- Показ кода:
  - Существующий код — CODE REFERENCE с диапазоном строк.
  - Новый/предложенный — markdown-блоки с указанием языка.

### Общие договорённости
- Стек: Next.js 15 (App Router, `app/`), React 19, TypeScript (strict), Turbopack.
- Алиасы импортов: `@/*` — абсолютные от корня репозитория.
- UI: MUI (Material UI) — приоритетная библиотека для пользовательских интерфейсов.
  - Базовые поверхности/формы/навигация: компоненты `@mui/material`.
  - SSR настроен через `AppRouterCacheProvider` (`@mui/material-nextjs`) — не отключать.
  - Tailwind v4 допускается точечно для утилитарных отступов/мелких классов, но не вместо MUI-компонентов.
  - Редакторы плагинов должны использовать MUI‑контролы (TextField, Select, Switch, Tabs и т.д.).
- Переменные окружения: локально в `.env.local` (не коммитить). Клиентские — `NEXT_PUBLIC_*`. Добавляй `.env.example` при вводе новых переменных.

### Стиль кода
- TypeScript: явные типы для экспортируемых API. Не использовать `any`.
- Управление потоком: ранние возвраты, избегать глубокой вложенности, минимум try/catch.
- Комментарии: только для неочевидного контекста, инвариантов и оговорённых крайних случаев.
- Форматирование: соблюдать текущий стиль файла, не переоформлять несвязанный код.

### Рабочий процесс
- Малые правки — минимальные диффы, атомарные коммиты (Conventional Commits: `feat:`, `fix:`, `chore:`, `refactor:`).
- В PR описывать цель, ключевые изменения и риск/миграции. Коротко.
- Перед коммитом: линт только изменённых файлов. Исправлять ошибки/варнинги.
- **ВАЖНО: НИКОГДА не использовать git-команды (commit, push, pull и т.д.). Только показывать пользователю, что нужно сделать.**

### Инструменты и команды
- Запуск: `yarn dev`
- Сборка: `yarn build`
- Прод: `yarn start`
- Линт: `yarn lint`

### Диалоги и вывод кода
- Не вставляй «голые» URL; используй бэктики либо markdown-ссылки.
- Для больших кусков кода — показывай только существенные фрагменты, остальное сворачивай комментариями.

### Идентификация пользователей
- ID пользователя системы — это хеш MAC‑адреса устройства.
- Стандартная функция вычисления: `hashMacAddress` из `@lib/hash`.
- Нормализация MAC перед хешированием: верхний регистр, удаление не шестнадцатеричных символов.
- Хеш может вычисляться как на сервере, так и в клиенте; в URL‑сегментах (например, `/settings/[id]`) используется именно этот ID.

### Настройки, плагины и данные плагинов
- **Структура настроек:**
  - Пользователь: `{ name: string; age: number }`
  - Устройство: `{ pluginId: string; pluginSettings: unknown }`
  - Полная модель: `Settings = { user, device }` (см. `@lib/settings`)
- **Хранение настроек:**
  - Локально на клиенте по ключу `settings:<id>`, где `id` — хеш MAC.
  - В БД: коллекция `settings`, документ с `_id = <id>` (`hash(MAC)`), upsert по `PUT /api/settings/[id]`.
- **Выбор плагина:**
  - Если записи в `settings` нет — используется плагин `registration` (QR на `/settings/<id>`).
  - Если запись есть — используется `settings.device.pluginId` и его `pluginSettings`.
- **Размещение плагинов:** `plugins/${pluginName}` с регистрацией в `plugins/index.ts`.
- **Контракт плагина (см. `plugins/types.ts`):**
  - `Plugin<TSettings, TData>`:
    - `id: string`, `name: string`
    - `outputSizes: Array<{ width?: number; height?: number }>` — список поддерживаемых размеров; пустой массив означает «без ограничений».
    - `defaultSettings: TSettings` — значения настроек по умолчанию.
    - `defaultData?: TData` — значения по умолчанию для внешних данных плагина.
    - `validate(value): value is TSettings` — рантайм‑валидация настроек плагина.
    - `dataStrategy?: "none" | "append" | "replace"` — стратегия хранения данных плагина во внешнем хранилище:
      - `none` — плагин не использует отдельное хранилище данных;
      - `append` — каждое новое значение `data` добавляется в коллекцию `data_device_<pluginId>` как отдельный документ;
      - `replace` — в `data_device_<pluginId>` хранится один документ на устройство, новое значение перезаписывает старое.
    - `editor: () => Promise<React.ComponentType<PluginEditorProps<TSettings>>>` — ленивый редактор настроек.
    - `render(args: RenderArgs<TSettings, TData>): Promise<MonochromeImage> | ReactElement`.
  - `RenderArgs<TSettings, TData>`:
    - `user?: UserSettings` — данные о пользователе (`{ name, age }`);
    - `settings?: TSettings` — настройки плагина из `settings.device.pluginSettings`;
    - `data?: TData` — последние данные плагина, загруженные внешним кодом из БД (через `db/dataDevice.ts` и `Plugin.dataStrategy`);
    - `dataCreatedAt?: Date` — метка времени `createdAt` для `data` (последнее сохранённое значение: последняя запись для `append` / единственная для `replace`);
    - `context: { deviceId: string | null; baseUrl: string; telegramId?: string | null }` — контекст устройства/окружения;
    - `index: number` — порядковый номер блока на экране (начиная с 1);
    - `width: number`, `height: number` — целевой размер изображения.

### Telegram‑бот и плагин `telegram`
- **Webhook и runtime:**
  - Весь Telegram‑бот реализован в `app/api/telegram/webhook/route.ts` через `grammy` (`Bot`) и `webhookCallback`.
  - Роут работает в Node.js runtime (`export const runtime = "nodejs"`), получает апдейты напрямую от Telegram.
- **Привязка аккаунта:**
  - Команда `/start <код>`:
    - проверяет `linkCode` по коллекции `telegram_links` (`TelegramLinkDoc`);
    - создаёт или обновляет запись в коллекции `accounts` (`AccountDoc`) с `provider: "telegram"` и `providerAccountId = telegramId`;
    - удаляет использованный код из `telegram_links`;
    - отвечает пользователю об успешной привязке.
- **Список устройств и помощь:**
  - `/devices`:
    - по Telegram‑аккаунту находит `AccountDoc`, затем активные `DeviceMemberDoc` и соответствующие `DeviceDoc`;
    - выводит список устройств с ролью, hash, последним обновлением и уровнем батареи;
    - формат ответа — Markdown.
  - `/help`:
    - кратко описывает доступные команды (`/start`, `/devices`, `/help`).
- **Передача сообщений в плагин `telegram`:**
  - Текстовые апдейты обрабатываются в двух хендлерах:
    - `bot.on("message:text", ...)` — новые сообщения;
    - `bot.on("edited_message:text", ...)` — отредактированные сообщения.
  - Оба хендлера вызывают общую функцию `processUserTextMessage`, которая:
    - игнорирует команды (`/...`), пустой текст и случаи без `telegramId`;
    - находит `AccountDoc` по `provider: "telegram"`;
    - по `account.userId` находит активные `device_members` и соответствующие `devices`;
    - фильтрует устройства по наличию плагина `telegram` в `device.plugins`.
  - Форматирование сообщений:
    - из `ctx.message.text` и `ctx.message.entities` собирается строка Markdown через `formatTelegramTextAsMarkdown`;
    - поддерживаются типы сущностей Telegram: `bold`, `italic`, `underline`, `strikethrough`, `code`, `pre`, `text_link`;
    - сохраняется именно Markdown‑строка (не HTML).
  - Сохранение данных плагина:
    - данные для плагина `telegram` хранятся в коллекции `data_device_telegram` с типом `DataDeviceTelegramDoc = DataDevicePlugin<string>`;
    - сохранение выполняется через `saveDevicePluginData<string>({ pluginId: "telegram", deviceId, data, createdBy, strategy: "replace" })`;
    - стратегия `"replace"` гарантирует один документ на устройство; при редактировании сообщения значение и `createdAt` перезаписываются.
  - Рассылка по устройствам:
    - если у пользователя нет устройств с плагином `telegram` — бот пишет об этом в ответ;
    - если устройство одно — сообщение отправляется на него, бот отвечает с указанием alias/hash;
    - если устройств несколько — сообщение сохраняется и отправляется на все найденные устройства.
- **Рендер плагина `telegram`:**
  - Плагин зарегистрирован как `plugins/telegram`, тип `Plugin<TelegramSettings, string>`, `dataStrategy: "replace"`, `defaultData: ""`.
  - Серверные рендер‑роуты (`/api/render/device`, `/api/render/plugin`):
    - загружают данные через `loadDevicePluginData<string>()`, получают документ `DataDevicePlugin<string>`;
    - передают в `render` плагина:
      - `data` — Markdown‑строку сообщения;
      - `dataCreatedAt` — `createdAt` из документа (дата последнего сохранения сообщения).
  - Сам рендер (`plugins/telegram/Render.tsx`):
    - использует `react-markdown` + `remark-gfm` для отображения Markdown в OG‑контексте;
    - обрабатывает inline‑форматирование (жирный, курсив, подчёркнутый, зачёркнутый, код, ссылки) и списки/переносы строк;
    - внизу экрана показывает дату/время последнего сообщения по `dataCreatedAt`;
    - если Telegram‑аккаунт не привязан (`context.telegramId` отсутствует) — выводит инструкцию по привязке;
    - если сообщений ещё не было — показывает текст‑заглушку с ссылкой на Telegram‑бота.
- Формат изображения `MonochromeImage`:
  - `width`, `height` — пиксели
  - `data: Uint8Array` — 1‑бит на пиксель, упаковано побайтно (MSB→LSB), строка за строкой
- UI страницы `/settings/[id]`:
  - Поля пользователя: имя, возраст
  - Выбор плагина из реестра
  - Редактирование `pluginSettings` в JSON c валидацией через `plugin.validate`

### Устройство TRMNL (BYOS)
- Целевой дисплей: 800×480 px, 1‑бит (монохром), итоговый формат для устройства — BMP.
- Рекомендация по рендеру: плагин возвращает `MonochromeImage` (raw 1‑бит), конвертацию в BMP выполняет серверный API‑роут.
- Ориентация экрана:
  - По умолчанию `landscape`; возможно `portrait` в настройках плагина.
  - Размер `outputSize` плагина остаётся фиксированным, вращение контента — ответственность плагина/рендера.
- Эндпоинты BYOS:
  - `/api/setup` — первичная регистрация устройства (принимает MAC, выдаёт/подтверждает API‑ключ).
  - `/api/display` — отдаёт ссылку на изображение и параметры обновления (sleep/refresh).
  - `/api/log` — сбор логов устройства.
- Ссылка на специфику реализации и формат: см. BYOS Next.js для TRMNL — README (`https://github.com/usetrmnl/byos_next/blob/main/README.md`).


